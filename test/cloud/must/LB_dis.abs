module LB_dis;

import * from LocalDC;

// data Req = Req(Client client, Content co);
// type Res = Res(Client client, Content co);
// type Content = Int; // for fibonacci
type Req = Int;
type Res = Int;

interface Balancer {
    Unit forwardReq(Client c, Req r);
    Unit forwardRes(Client c, Res r);
    Unit serverLoaded();
    //Bool serverIdle(Server s);
}

interface Server {
    Unit serve(Client c, Req r);
}

interface Client {
    Unit respond(Res r);
}

// simplistic load balancer of jobs
class B(Int initFarmSize) implements Balancer {
   List<Server> farm = Nil;
   Int rr = 0;                  // the farm index in a round-robin
   {
       Int i = initFarmSize;
       List<IDC> dcs = Nil;
       IDC dc;
       while (i > 0) {          // create the VMs for the farm
           dc = new local LocalDC(9000+i);
           dcs = Cons(dc, dcs);
           i = i-1;
       }
       Server s;
       while (dcs != Nil) { // start a server in each VM
            dc = head(dcs);
            s = dc spawns S(this);      //should be spawns
            farm = Cons(s,farm);
            i = i+1;
            dcs=tail(dcs);
       }
   }
   Unit forwardReq(Client c, Req req) {
       nth(farm,rr) ! serve(c,req);
       rr = if (rr >= length(farm)-1) then 0 else rr+1;
   }
   Unit forwardRes(Client c, Res rsp) { c ! respond(rsp); }

   Unit serverLoaded() {
       // new DC
   }
   // Bool serverIdle(Server s) {
   //     Bool canStop = False;
   //     if (length(farm)>0) { // we keep 1 at list
   //         //farm = delete(s,farm); // remove serv from servs
   //         canStop = True;
   //     }
   //     return canStop;
   // }
}

class S(Balancer b) implements Server {
    Unit serve(Client c, Req r) {
        Rat lastMinLoad = 2/3; //  fst(thisDC ! load)
        if (lastMinLoad > 75/100) { b ! serverLoaded(); }
        // else {
        //     if (lastMinLoad < 10/100) {
        //         Fut<Bool> f = b ! serverIdle(this);
        //         Bool b = f.get;
        //         if (b) { this ! cleanup(); } // cleanup will run after sending the response because of cooperative scheduling
        //     }
        // }
        Res res = 3; // fib(r);
        b ! forwardRes(c, res);
    }
    Unit cleanup() {
        // cleanup
        // thisDC ! shutdown();
    }
}

class C implements Client {
    Unit respond(Res r) {
        println(toString(r));
    }
} 


//this will not show, this generates the requests
{
 Int f = 4;
 Balancer b = new B(f);
 Int cs = 50000;
 Client c;
 while (cs>0) {
     c = new local C();
     b ! forwardReq(c, 4);
     // should wait for a while
     cs=cs-1;
 }
}