module LB_fixed;

import * from NebulaDC;

//interface IDC { }  // stub for non-haskell backend

type Req = Int;
type Res = Int;

def Int fib(Int n) = case n {
       0 => 0;
       1 => 1;
       n_ => fib(n-1) + fib(n-2);
};

interface IBalancer {
    // behaves like a reverse proxy
    Unit forwardReq(IClient c, Req r);
    Unit forwardRes(IClient c, Res r);
}

interface IServer {
    Unit processRequest(IClient c, Req r);
}

interface IClient {
    Unit processResponse(Res r);
}

class Balancer(Int initFarmSize) implements IBalancer {
   List<IServer> farm = Nil;
   Int rr = 0;                  // the farm index in a round-robin
   {
       Int i = initFarmSize;
       List<IDC> dcs = Nil;
       IDC dc;
       while (i > 0) {          // create the VMs for the farm
           dc = new NebulaDC(1,8192);  // null; for non-haskell backend
           dcs = Cons(dc, dcs);
           i = i-1;
       }
       IServer s;
       while (dcs != Nil) { // start a server in each VM
            dc = head(dcs);
            s = dc spawns Server(this); // new Server(this); for non-haskell backend
            farm = Cons(s,farm);
            i = i+1;
            dcs=tail(dcs);
       }
   }
   Unit forwardReq(IClient c, Req req) {
       nth(farm,rr) ! processRequest(c,req);
       rr = if (rr >= length(farm)-1) then 0 else rr+1;
   }
   Unit forwardRes(IClient c, Res rsp) { c ! processResponse(rsp); }
}

class Server(IBalancer b) implements IServer {
    Unit processRequest(IClient c, Req r) {
        Res res = fib(r);
        b ! forwardRes(c, res);
    }
}

class Client implements IClient {
    Unit processResponse(Res r) {
        println("Job done:");
        println(toString(r));
    }
} 

// main
{

 Int fixedFarmSize = 4;
 IBalancer b = new Balancer(fixedFarmSize);

 Int numberOfClients = 1000;
 IClient c;
 Int fixedJobSize = 38;
 while (numberOfClients>0) {
     c = new local Client();
     b ! forwardReq(c, fixedJobSize);
     numberOfClients=numberOfClients-1;
 }

}